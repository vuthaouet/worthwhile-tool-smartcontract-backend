{"contract": "king_of_the_ether_throne", "sourceLanguage": "Solidity", "count_risk_of_false_positives": 15, "list_vulnerabilities": ["UncheckedLowCallsVulnerability", "OtherVulnerability", "DenialServiceVulnerability", "FrontRunningVulnerability", "ArithmeticVulnerability", "TimeManipulationVulnerability"], "rules": [{"id": "UncheckedLowCalls_3", "fullDescription": {"text": "The return value of an external call is not checked. Note that execution continue even if the called contract throws."}, "name": "UncheckedLowCallsVulnerability", "shortDescription": {"text": "Unchecked CALL return value"}}, {"id": "Other_10", "fullDescription": {"text": "Multiple sends exist in one transaction, try to isolate each external call into its own transaction. As external calls can fail accidentally or deliberately.\nConsecutive calls: \nCall at address: 1337\n"}, "name": "OtherVulnerability", "shortDescription": {"text": "Multiple Calls"}}, {"id": "FrontRunning_1", "fullDescription": {"text": "A possible transaction order independence vulnerability exists in function fallback. The value or direction of the call statement is determined from a tainted storage location"}, "name": "FrontRunningVulnerability", "shortDescription": {"text": "Transaction order dependence"}}, {"id": "Arithmetic_4", "fullDescription": {"text": "A possible integer overflow exists in the function `fallback`.\nThe addition or multiplication may result in a value higher than the maximum representable integer."}, "name": "ArithmeticVulnerability", "shortDescription": {"text": "Integer Overflow"}}, {"id": "Other_9", "fullDescription": {"text": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. "}, "name": "OtherVulnerability", "shortDescription": {"text": "Exception state"}}, {"id": "TimeManipulation_4", "fullDescription": {"text": "KingOfTheEtherThrone.claimThrone (/data/demo_analysis/source_code/king_of_the_ether_throne.sol#103-169) uses timestamp for comparisons\n\tDangerous comparisons:\n\t- currentMonarch.etherAddress != wizardAddress (/data/demo_analysis/source_code/king_of_the_ether_throne.sol#130-135)\n"}, "name": "TimeManipulationVulnerability", "shortDescription": {"text": "timestamp"}}, {"id": "Arithmetic_12", "name": "ArithmeticVulnerability", "shortDescription": {"text": "Integer Underflow."}}, {"id": "Arithmetic_11", "name": "ArithmeticVulnerability", "shortDescription": {"text": "Integer Overflow."}}, {"id": "DenialService_2", "name": "DenialServiceVulnerability", "shortDescription": {"text": "Callstack Depth Attack Vulnerability."}}], "listLine": [110, 118, 132, 2, 139, 174, 69, 26, 103, 130, 66], "analysis": {"110": [{"level": "note", "tool": ["mythril"], "snippet": {"text": "msg.sender.send(valuePaid)"}, "fullDescription": "The return value of an external call is not checked. Note that execution continue even if the called contract throws.", "name": "UncheckedLowCallsVulnerability", "flag": "risk of false positives"}], "118": [{"level": "warning", "tool": ["mythril"], "snippet": {"text": "msg.sender.send(excessPaid)"}, "fullDescription": "Multiple sends exist in one transaction, try to isolate each external call into its own transaction. As external calls can fail accidentally or deliberately.\nConsecutive calls: \nCall at address: 1337\n", "name": "OtherVulnerability", "flag": "risk of false positives"}, {"level": "note", "tool": ["mythril"], "fullDescription": "The return value of an external call is not checked. Note that execution continue even if the called contract throws.", "name": "UncheckedLowCallsVulnerability", "flag": "risk of false positives"}, {"level": "warning", "tool": ["oyente"], "name": "DenialServiceVulnerability", "flag": "risk of false positives"}], "132": [{"level": "warning", "tool": ["mythril"], "snippet": {"text": "currentMonarch.etherAddress.send(compensation)"}, "fullDescription": "A possible transaction order independence vulnerability exists in function fallback. The value or direction of the call statement is determined from a tainted storage location", "name": "FrontRunningVulnerability", "flag": "risk of false positives"}, {"level": "note", "tool": ["mythril"], "fullDescription": "The return value of an external call is not checked. Note that execution continue even if the called contract throws.", "name": "UncheckedLowCallsVulnerability", "flag": "risk of false positives"}, {"level": "warning", "tool": ["oyente"], "name": "DenialServiceVulnerability", "flag": "risk of false positives"}], "2": [{"level": "warning", "tool": ["mythril"], "snippet": {"text": "github.com/kierane"}, "fullDescription": "A possible integer overflow exists in the function `fallback`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "name": "ArithmeticVulnerability"}], "139": [{"level": "warning", "tool": ["mythril"], "snippet": {"text": "currentMonarch = Monarch(\n            msg.sender,\n            name,\n            valuePaid,\n            block.timestamp\n        )"}, "fullDescription": "A possible integer overflow exists in the function `fallback`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "name": "ArithmeticVulnerability"}], "174": [{"level": "warning", "tool": ["mythril"], "snippet": {"text": "wizardAddress.send(amount)"}, "fullDescription": "A possible transaction order independence vulnerability exists in function fallback. The value or direction of the call statement is determined from a tainted storage location", "name": "FrontRunningVulnerability", "flag": "risk of false positives"}, {"level": "note", "tool": ["mythril"], "fullDescription": "The return value of an external call is not checked. Note that execution continue even if the called contract throws.", "name": "UncheckedLowCallsVulnerability", "flag": "risk of false positives"}], "69": [{"level": "note", "tool": ["mythril"], "snippet": {"text": "Monarch[] public pastMonarchs"}, "fullDescription": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "name": "OtherVulnerability", "flag": "risk of false positives"}, {"level": "warning", "tool": ["oyente"], "name": "ArithmeticVulnerability", "flag": "risk of false positives"}], "26": [{"level": "warning", "tool": ["mythril"], "snippet": {"text": "contract KingOfTheEtherThrone {\n\n    struct Monarch {\n        // Address to which their compensation will be sent.\n        address etherAddress;\n        // A name by which they wish to be known.\n        // NB: Unfortunately \"string\" seems to expose some bugs in web3.\n        string name;\n        // How much did they pay to become monarch?\n        uint claimPrice;\n        // When did their rule start (based on block.timestamp)?\n        uint coronationTimestamp;\n    }\n\n    // The wizard is the hidden power behind the throne; they\n    // occupy the throne during gaps in succession and collect fees.\n    address wizardAddress;\n\n    // Used to ensure only the wizard can do some things.\n    modifier onlywizard { if (msg.sender == wizardAddress) _; }\n\n    // How much must the first monarch pay?\n    uint constant startingClaimPrice = 100 finney;\n\n    // The next claimPrice is calculated from the previous claimFee\n    // by multiplying by claimFeeAdjustNum and dividing by claimFeeAdjustDen -\n    // for example, num=3 and den=2 would cause a 50% increase.\n    uint constant claimPriceAdjustNum = 3;\n    uint constant claimPriceAdjustDen = 2;\n\n    // How much of each claimFee goes to the wizard (expressed as a fraction)?\n    // e.g. num=1 and den=100 would deduct 1% for the wizard, leaving 99% as\n    // the compensation fee for the usurped monarch.\n    uint constant wizardCommissionFractionNum = 1;\n    uint constant wizardCommissionFractionDen = 100;\n\n    // How much must an agent pay now to become the monarch?\n    uint public currentClaimPrice;\n\n    // The King (or Queen) of the Ether.\n    Monarch public currentMonarch;\n\n    // Earliest-first list of previous throne holders.\n    Monarch[] public pastMonarchs;\n\n    // Create a new throne, with the creator as wizard and first ruler.\n    // Sets up some hopefully sensible defaults.\n    function KingOfTheEtherThrone() {\n        wizardAddress = msg.sender;\n        currentClaimPrice = startingClaimPrice;\n        currentMonarch = Monarch(\n            wizardAddress,\n            \"[Vacant]\",\n            0,\n            block.timestamp\n        );\n    }\n\n    function numberOfMonarchs() constant returns (uint n) {\n        return pastMonarchs.length;\n    }\n\n    // Fired when the throne is claimed.\n    // In theory can be used to help build a front-end.\n    event ThroneClaimed(\n        address usurperEtherAddress,\n        string usurperName,\n        uint newClaimPrice\n    );\n\n    // Fallback function - simple transactions trigger this.\n    // Assume the message data is their desired name.\n    function() {\n        claimThrone(string(msg.data));\n    }\n\n    // Claim the throne for the given name by paying the currentClaimFee.\n    function claimThrone(string name) {\n\n        uint valuePaid = msg.value;\n\n        // If they paid too little, reject claim and refund their money.\n        if (valuePaid < currentClaimPrice) {\n            // <yes> <report> UNCHECKED_LL_CALLS\n            msg.sender.send(valuePaid);\n            return;\n        }\n\n        // If they paid too much, continue with claim but refund the excess.\n        if (valuePaid > currentClaimPrice) {\n            uint excessPaid = valuePaid - currentClaimPrice;\n            // <yes> <report> UNCHECKED_LL_CALLS\n            msg.sender.send(excessPaid);\n            valuePaid = valuePaid - excessPaid;\n        }\n\n        // The claim price payment goes to the current monarch as compensation\n        // (with a commission held back for the wizard). We let the wizard's\n        // payments accumulate to avoid wasting gas sending small fees.\n\n        uint wizardCommission = (valuePaid * wizardCommissionFractionNum) / wizardCommissionFractionDen;\n\n        uint compensation = valuePaid - wizardCommission;\n\n        if (currentMonarch.etherAddress != wizardAddress) {\n            // <yes> <report> UNCHECKED_LL_CALLS\n            currentMonarch.etherAddress.send(compensation);\n        } else {\n            // When the throne is vacant, the fee accumulates for the wizard.\n        }\n\n        // Usurp the current monarch, replacing them with the new one.\n        pastMonarchs.push(currentMonarch);\n        currentMonarch = Monarch(\n            msg.sender,\n            name,\n            valuePaid,\n            block.timestamp\n        );\n\n        // Increase the claim fee for next time.\n        // Stop number of trailing decimals getting silly - we round it a bit.\n        uint rawNewClaimPrice = currentClaimPrice * claimPriceAdjustNum / claimPriceAdjustDen;\n        if (rawNewClaimPrice < 10 finney) {\n            currentClaimPrice = rawNewClaimPrice;\n        } else if (rawNewClaimPrice < 100 finney) {\n            currentClaimPrice = 100 szabo * (rawNewClaimPrice / 100 szabo);\n        } else if (rawNewClaimPrice < 1 ether) {\n            currentClaimPrice = 1 finney * (rawNewClaimPrice / 1 finney);\n        } else if (rawNewClaimPrice < 10 ether) {\n            currentClaimPrice = 10 finney * (rawNewClaimPrice / 10 finney);\n        } else if (rawNewClaimPrice < 100 ether) {\n            currentClaimPrice = 100 finney * (rawNewClaimPrice / 100 finney);\n        } else if (rawNewClaimPrice < 1000 ether) {\n            currentClaimPrice = 1 ether * (rawNewClaimPrice / 1 ether);\n        } else if (rawNewClaimPrice < 10000 ether) {\n            currentClaimPrice = 10 ether * (rawNewClaimPrice / 10 ether);\n        } else {\n            currentClaimPrice = rawNewClaimPrice;\n        }\n\n        // Hail the new monarch!\n        ThroneClaimed(currentMonarch.etherAddress, currentMonarch.name, currentClaimPrice);\n    }\n\n    // Used only by the wizard to collect his commission.\n    function sweepCommission(uint amount) onlywizard {\n        // <yes> <report> UNCHECKED_LL_CALLS\n        wizardAddress.send(amount);\n    }\n\n    // Used only by the wizard to collect his commission.\n    function transferOwnership(address newOwner) onlywizard {\n        wizardAddress = newOwner;\n    }\n\n}"}, "fullDescription": "A possible integer overflow exists in the function `fallback`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "name": "ArithmeticVulnerability"}, {"level": "warning", "tool": ["mythril"], "fullDescription": "A possible integer overflow exists in the function `fallback`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "name": "ArithmeticVulnerability"}, {"level": "warning", "tool": ["mythril"], "fullDescription": "A possible integer overflow exists in the function `fallback`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "name": "ArithmeticVulnerability"}, {"level": "warning", "tool": ["mythril"], "fullDescription": "A possible integer overflow exists in the function `fallback`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "name": "ArithmeticVulnerability"}], "103": [{"level": "warning", "tool": ["slither"], "fullDescription": "KingOfTheEtherThrone.claimThrone (/data/demo_analysis/source_code/king_of_the_ether_throne.sol#103-169) uses timestamp for comparisons\n\tDangerous comparisons:\n\t- currentMonarch.etherAddress != wizardAddress (/data/demo_analysis/source_code/king_of_the_ether_throne.sol#130-135)\n", "name": "TimeManipulationVulnerability", "flag": "risk of false positives"}, {"level": "warning", "tool": ["oyente"], "name": "ArithmeticVulnerability", "flag": "risk of false positives"}], "130": [{"level": "warning", "tool": ["slither"], "snippet": {"text": "currentMonarch.etherAddress != wizardAddress"}, "fullDescription": "KingOfTheEtherThrone.claimThrone (/data/demo_analysis/source_code/king_of_the_ether_throne.sol#103-169) uses timestamp for comparisons\n\tDangerous comparisons:\n\t- currentMonarch.etherAddress != wizardAddress (/data/demo_analysis/source_code/king_of_the_ether_throne.sol#130-135)\n", "name": "TimeManipulationVulnerability", "flag": "risk of false positives"}], "66": [{"level": "warning", "tool": ["oyente"], "snippet": {}, "name": "ArithmeticVulnerability", "flag": "risk of false positives"}]}, "count_vulnerabilities": {"UncheckedLowCallsVulnerability": 4, "OtherVulnerability": 2, "DenialServiceVulnerability": 2, "FrontRunningVulnerability": 2, "ArithmeticVulnerability": 9, "TimeManipulationVulnerability": 2}, "count_leve_vulnerabilities": {"warning": 16, "error": 0, "note": 5, "none": 0}, "false_positives": 0}