{"contract": "list_dos", "sourceLanguage": "Solidity", "analysis": {"121": [{"level": "warning", "tool": ["mythril"], "snippet": {"text": "function getCreditorAmounts() returns (uint[]) {\n         return creditorAmounts;\n     }"}, "fullDescription": "A possible integer overflow exists in the function `getCreditorAmounts()`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "name": "ArithmeticVulnerability"}], "117": [{"level": "warning", "tool": ["mythril"], "snippet": {"text": "function getCreditorAddresses() returns (address[]) {\n         return creditorAddresses;\n     }"}, "fullDescription": "A possible integer overflow exists in the function `getCreditorAmounts()`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "name": "ArithmeticVulnerability"}], "35": [{"level": "warning", "tool": ["mythril"], "snippet": {"text": "lastTimeOfNewCredit + TWELVE_HOURS"}, "fullDescription": "A possible integer overflow exists in the function `getCreditorAmounts()`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "name": "ArithmeticVulnerability"}, {"level": "warning", "tool": ["slither"], "fullDescription": "Government.lendGovernmentMoney (/data/demo_analysis/source_code/list_dos.sol#31-86) uses timestamp for comparisons\n\tDangerous comparisons:\n\t- lastTimeOfNewCredit + TWELVE_HOURS < block.timestamp (/data/demo_analysis/source_code/list_dos.sol#35-85)\n", "name": "TimeManipulationVulnerability"}], "37": [{"level": "warning", "tool": ["mythril"], "snippet": {"text": "msg.sender.send(amount)"}, "fullDescription": "Multiple sends exist in one transaction, try to isolate each external call into its own transaction. As external calls can fail accidentally or deliberately.\nConsecutive calls: \nCall at address: 1357\nCall at address: 1468\n", "name": "OtherVulnerability"}, {"level": "note", "tool": ["mythril"], "fullDescription": "The return value of an external call is not checked. Note that execution continue even if the called contract throws.", "name": "UncheckedLowCallsVulnerability"}, {"level": "warning", "tool": ["oyente"], "name": "DenialServiceVulnerability"}], "39": [{"level": "note", "tool": ["mythril"], "snippet": {"text": "creditorAddresses[creditorAddresses.length - 1]"}, "fullDescription": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "name": "OtherVulnerability"}, {"level": "warning", "tool": ["mythril"], "fullDescription": "In the function `fallback` a non-zero amount of Ether is sent to an address taken from storage slot 87903029871075914254377627908054574944891091886930582284385770809450030037083.\nThere is a check on storage index 87903029871075914254377627908054574944891091886930582284385770809450030037083. This storage slot can be written to by calling the function `fallback`.\n\nThere is a check on storage index 1. This storage slot can be written to by calling the function `fallback`.\nThere is a check on storage index 3. This storage slot can be written to by calling the function `fallback`.", "name": "AccessControlVulnerability"}, {"level": "warning", "tool": ["mythril"], "fullDescription": "A possible transaction order independence vulnerability exists in function fallback. The value or direction of the call statement is determined from a tainted storage location", "name": "FrontRunningVulnerability"}, {"level": "note", "tool": ["mythril"], "fullDescription": "The return value of an external call is not checked. Note that execution continue even if the called contract throws.", "name": "UncheckedLowCallsVulnerability"}, {"level": "warning", "tool": ["oyente"], "name": "DenialServiceVulnerability"}], "40": [{"level": "warning", "tool": ["mythril"], "snippet": {"text": "corruptElite.send(this.balance)"}, "fullDescription": "In the function `fallback` the following predictable state variables are used to determine Ether recipient:\n- block.timestamp\n", "name": "OtherVulnerability"}, {"level": "warning", "tool": ["mythril"], "fullDescription": "A possible transaction order independence vulnerability exists in function fallback. The value or direction of the call statement is determined from a tainted storage location", "name": "FrontRunningVulnerability"}, {"level": "note", "tool": ["mythril"], "fullDescription": "The return value of an external call is not checked. Note that execution continue even if the called contract throws.", "name": "UncheckedLowCallsVulnerability"}, {"level": "warning", "tool": ["oyente"], "name": "DenialServiceVulnerability"}], "62": [{"level": "warning", "tool": ["mythril"], "snippet": {"text": "corruptElite.send(amount * 5/100)"}, "fullDescription": "Multiple sends exist in one transaction, try to isolate each external call into its own transaction. As external calls can fail accidentally or deliberately.\nConsecutive calls: \nCall at address: 1357\nCall at address: 1468\n", "name": "OtherVulnerability"}, {"level": "note", "tool": ["mythril"], "fullDescription": "The return value of an external call is not checked. Note that execution continue even if the called contract throws.", "name": "UncheckedLowCallsVulnerability"}, {"level": "warning", "tool": ["oyente"], "name": "DenialServiceVulnerability"}], "70": [{"level": "note", "tool": ["mythril"], "snippet": {"text": "buddy.send(amount * 5/100)"}, "fullDescription": "The return value of an external call is not checked. Note that execution continue even if the called contract throws.", "name": "UncheckedLowCallsVulnerability"}, {"level": "warning", "tool": ["oyente"], "name": "DenialServiceVulnerability"}], "75": [{"level": "note", "tool": ["mythril"], "snippet": {"text": "creditorAddresses[lastCreditorPayedOut].send(creditorAmounts[lastCreditorPayedOut])"}, "fullDescription": "The return value of an external call is not checked. Note that execution continue even if the called contract throws.", "name": "UncheckedLowCallsVulnerability"}, {"level": "warning", "tool": ["oyente"], "name": "DenialServiceVulnerability"}], "82": [{"level": "note", "tool": ["mythril"], "snippet": {"text": "msg.sender.send(amount)"}, "fullDescription": "The return value of an external call is not checked. Note that execution continue even if the called contract throws.", "name": "UncheckedLowCallsVulnerability"}, {"level": "warning", "tool": ["oyente"], "name": "DenialServiceVulnerability"}], "101": [{"level": "note", "tool": ["mythril"], "snippet": {"text": "creditorAmounts[i]"}, "fullDescription": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "name": "OtherVulnerability"}], "122": [{"level": "warning", "tool": ["mythril"], "snippet": {"text": "return creditorAmounts"}, "fullDescription": "A possible integer overflow exists in the function `getCreditorAmounts()`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "name": "ArithmeticVulnerability"}, {"level": "warning", "tool": ["mythril"], "fullDescription": "A possible integer overflow exists in the function `getCreditorAmounts()`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "name": "ArithmeticVulnerability"}], "16": [{"level": "note", "tool": ["mythril"], "snippet": {"text": "address[] public creditorAddresses"}, "fullDescription": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "name": "OtherVulnerability"}], "118": [{"level": "warning", "tool": ["mythril"], "snippet": {"text": "return creditorAddresses"}, "fullDescription": "A possible integer overflow exists in the function `getCreditorAmounts()`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "name": "ArithmeticVulnerability"}, {"level": "warning", "tool": ["mythril"], "fullDescription": "A possible integer overflow exists in the function `getCreditorAmounts()`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "name": "ArithmeticVulnerability"}], "17": [{"level": "note", "tool": ["mythril"], "snippet": {"text": "uint[] public creditorAmounts"}, "fullDescription": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "name": "OtherVulnerability"}, {"level": "warning", "tool": ["oyente"], "name": "ArithmeticVulnerability"}], "10": [{"level": "warning", "tool": ["mythril"], "snippet": {"text": "contract Government {\n\n     // Global Variables\n     uint32 public lastCreditorPayedOut;\n     uint public lastTimeOfNewCredit;\n     uint public profitFromCrash;\n     address[] public creditorAddresses;\n     uint[] public creditorAmounts;\n     address public corruptElite;\n     mapping (address => uint) buddies;\n     uint constant TWELVE_HOURS = 43200;\n     uint8 public round;\n\n     function Government() {\n         // The corrupt elite establishes a new government\n         // this is the commitment of the corrupt Elite - everything that can not be saved from a crash\n         profitFromCrash = msg.value;\n         corruptElite = msg.sender;\n         lastTimeOfNewCredit = block.timestamp;\n     }\n\n     function lendGovernmentMoney(address buddy) returns (bool) {\n         uint amount = msg.value;\n         // check if the system already broke down. If for 12h no new creditor gives new credit to the system it will brake down.\n         // 12h are on average = 60*60*12/12.5 = 3456\n         if (lastTimeOfNewCredit + TWELVE_HOURS < block.timestamp) {\n             // Return money to sender\n             msg.sender.send(amount);\n             // Sends all contract money to the last creditor\n             creditorAddresses[creditorAddresses.length - 1].send(profitFromCrash);\n             corruptElite.send(this.balance);\n             // Reset contract state\n             lastCreditorPayedOut = 0;\n             lastTimeOfNewCredit = block.timestamp;\n             profitFromCrash = 0;\n            // <yes> <report> DENIAL_OF_SERVICE\n             creditorAddresses = new address[](0);\n            // <yes> <report> DENIAL_OF_SERVICE\n             creditorAmounts = new uint[](0);\n             round += 1;\n             return false;\n         }\n         else {\n             // the system needs to collect at least 1% of the profit from a crash to stay alive\n             if (amount >= 10 ** 18) {\n                 // the System has received fresh money, it will survive at leat 12h more\n                 lastTimeOfNewCredit = block.timestamp;\n                 // register the new creditor and his amount with 10% interest rate\n                 creditorAddresses.push(msg.sender);\n                 creditorAmounts.push(amount * 110 / 100);\n                 // now the money is distributed\n                 // first the corrupt elite grabs 5% - thieves!\n                 corruptElite.send(amount * 5/100);\n                 // 5% are going into the economy (they will increase the value for the person seeing the crash comming)\n                 if (profitFromCrash < 10000 * 10**18) {\n                     profitFromCrash += amount * 5/100;\n                 }\n                 // if you have a buddy in the government (and he is in the creditor list) he can get 5% of your credits.\n                 // Make a deal with him.\n                 if(buddies[buddy] >= amount) {\n                     buddy.send(amount * 5/100);\n                 }\n                 buddies[msg.sender] += amount * 110 / 100;\n                 // 90% of the money will be used to pay out old creditors\n                 if (creditorAmounts[lastCreditorPayedOut] <= address(this).balance - profitFromCrash) {\n                     creditorAddresses[lastCreditorPayedOut].send(creditorAmounts[lastCreditorPayedOut]);\n                     buddies[creditorAddresses[lastCreditorPayedOut]] -= creditorAmounts[lastCreditorPayedOut];\n                     lastCreditorPayedOut += 1;\n                 }\n                 return true;\n             }\n             else {\n                 msg.sender.send(amount);\n                 return false;\n             }\n         }\n     }\n\n     // fallback function\n     function() {\n         lendGovernmentMoney(0);\n     }\n\n     function totalDebt() returns (uint debt) {\n         for(uint i=lastCreditorPayedOut; i<creditorAmounts.length; i++){\n             debt += creditorAmounts[i];\n         }\n     }\n\n     function totalPayedOut() returns (uint payout) {\n         for(uint i=0; i<lastCreditorPayedOut; i++){\n             payout += creditorAmounts[i];\n         }\n     }\n\n     // better don't do it (unless you are the corrupt elite and you want to establish trust in the system)\n     function investInTheSystem() {\n         profitFromCrash += msg.value;\n     }\n\n     // From time to time the corrupt elite inherits it's power to the next generation\n     function inheritToNextGeneration(address nextGeneration) {\n         if (msg.sender == corruptElite) {\n             corruptElite = nextGeneration;\n         }\n     }\n\n     function getCreditorAddresses() returns (address[]) {\n         return creditorAddresses;\n     }\n\n     function getCreditorAmounts() returns (uint[]) {\n         return creditorAmounts;\n     }\n }"}, "fullDescription": "A possible integer overflow exists in the function `getCreditorAmounts()`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "name": "ArithmeticVulnerability"}, {"level": "warning", "tool": ["mythril"], "fullDescription": "A possible integer overflow exists in the function `getCreditorAmounts()`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "name": "ArithmeticVulnerability"}], "31": [{"level": "warning", "tool": ["slither"], "fullDescription": "Government.lendGovernmentMoney (/data/demo_analysis/source_code/list_dos.sol#31-86) uses timestamp for comparisons\n\tDangerous comparisons:\n\t- lastTimeOfNewCredit + TWELVE_HOURS < block.timestamp (/data/demo_analysis/source_code/list_dos.sol#35-85)\n", "name": "TimeManipulationVulnerability"}]}, "listLine": [121, 117, 35, 37, 39, 40, 62, 70, 75, 82, 101, 122, 16, 118, 17, 10, 31], "rules": [{"id": "Arithmetic_4", "fullDescription": {"text": "A possible integer overflow exists in the function `getCreditorAmounts()`.\nThe addition or multiplication may result in a value higher than the maximum representable integer."}, "name": "ArithmeticVulnerability", "shortDescription": {"text": "Integer Overflow"}}, {"id": "Other_10", "fullDescription": {"text": "Multiple sends exist in one transaction, try to isolate each external call into its own transaction. As external calls can fail accidentally or deliberately.\nConsecutive calls: \nCall at address: 1357\nCall at address: 1468\n"}, "name": "OtherVulnerability", "shortDescription": {"text": "Multiple Calls"}}, {"id": "UncheckedLowCalls_3", "fullDescription": {"text": "The return value of an external call is not checked. Note that execution continue even if the called contract throws."}, "name": "UncheckedLowCallsVulnerability", "shortDescription": {"text": "Unchecked CALL return value"}}, {"id": "Other_9", "fullDescription": {"text": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. "}, "name": "OtherVulnerability", "shortDescription": {"text": "Exception state"}}, {"id": "Other_7", "fullDescription": {"text": "In the function `fallback` the following predictable state variables are used to determine Ether recipient:\n- block.timestamp\n"}, "name": "OtherVulnerability", "shortDescription": {"text": "Dependence on predictable environment variable"}}, {"id": "AccessControl_13", "fullDescription": {"text": "In the function `fallback` a non-zero amount of Ether is sent to an address taken from storage slot 87903029871075914254377627908054574944891091886930582284385770809450030037083.\nThere is a check on storage index 87903029871075914254377627908054574944891091886930582284385770809450030037083. This storage slot can be written to by calling the function `fallback`.\n\nThere is a check on storage index 1. This storage slot can be written to by calling the function `fallback`.\nThere is a check on storage index 3. This storage slot can be written to by calling the function `fallback`."}, "name": "AccessControlVulnerability", "shortDescription": {"text": "Ether send"}}, {"id": "FrontRunning_1", "fullDescription": {"text": "A possible transaction order independence vulnerability exists in function fallback. The value or direction of the call statement is determined from a tainted storage location"}, "name": "FrontRunningVulnerability", "shortDescription": {"text": "Transaction order dependence"}}, {"id": "TimeManipulation_4", "fullDescription": {"text": "Government.lendGovernmentMoney (/data/demo_analysis/source_code/list_dos.sol#31-86) uses timestamp for comparisons\n\tDangerous comparisons:\n\t- lastTimeOfNewCredit + TWELVE_HOURS < block.timestamp (/data/demo_analysis/source_code/list_dos.sol#35-85)\n"}, "name": "TimeManipulationVulnerability", "shortDescription": {"text": "timestamp"}}, {"id": "Arithmetic_11", "name": "ArithmeticVulnerability", "shortDescription": {"text": "Integer Overflow."}}, {"id": "DenialService_2", "name": "DenialServiceVulnerability", "shortDescription": {"text": "Callstack Depth Attack Vulnerability."}}]}